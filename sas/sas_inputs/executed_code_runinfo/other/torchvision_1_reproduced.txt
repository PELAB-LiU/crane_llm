# Executed Cells:
## Cell 1:

from IPython.display import Image, display
import os
import random


directory_path = 'data_small/indoorCVPR_09/Images/'

def load_random_image_from_category(category_path):

    image_files = [file for file in os.listdir(category_path) if file.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp'))]


    random_image = random.choice(image_files)

    return random_image


categories = os.listdir(directory_path)


num_classes = 5


selected_categories = random.sample(categories, num_classes)


for category_name in selected_categories:
    category_path = os.path.join(directory_path, category_name)


    if os.path.isdir(category_path):
        random_image_name = load_random_image_from_category(category_path)
        random_image_path = os.path.join(category_path, random_image_name)

        print(f"Category: {category_name}")
        display(Image(filename=random_image_path))
        print("\n" + "="*30 + "\n")

## Cell 2:

from torchvision.datasets import ImageFolder
import torchvision.transforms as transforms

transformations = transforms.Compose([transforms.Resize((256, 256)), transforms.ToTensor()])

dataset = ImageFolder(directory_path, transform = transformations)

## Cell 3:

import matplotlib.pyplot as plt
import torch

def show_images(dataset, num_images=6):


    random_indices = torch.randperm(len(dataset))[:num_images]


    rows = 1
    cols = num_images
    fig, axes = plt.subplots(rows, cols, figsize=(15, 3))

    for i, idx in enumerate(random_indices):

        image, label = dataset[idx]


        image_np = image.permute(1, 2, 0).numpy()


        axes[i].imshow(image_np)
        axes[i].set_title(f"Label: {label}")


        axes[i].axis("off")

    plt.show()


transformed = dataset
show_images(transformed)

## Cell 4:

from torch.utils.data import random_split

class_mapping = transformed.class_to_idx
num_classes = len(class_mapping)


train_size = 420
val_size = 150
test_size = 100

train_indices, val_indices, test_indices = random_split(
    range(len(transformed)),
    [train_size, val_size, test_size]
)


train_ds = torch.utils.data.Subset(transformed, train_indices)
val_ds = torch.utils.data.Subset(transformed, val_indices)
test_ds = torch.utils.data.Subset(transformed, test_indices)


print(len(train_ds), len(val_ds), len(test_ds))

## Cell 5:

from torch.utils.data import DataLoader

batch_size = 25



train_dl = DataLoader(train_ds, batch_size, shuffle = True, num_workers = 0, pin_memory = False)
val_dl = DataLoader(val_ds, batch_size*2, num_workers = 0, pin_memory = False)

## Cell 6:

import torch.nn as nn
def accuracy(outputs, labels):
    _, preds = torch.max(outputs, dim=1)
    return torch.tensor(torch.sum(preds == labels).item() / len(preds))

class ImageClassificationBase(nn.Module):
    def training_step(self, batch):
        images, labels = batch
        out = self(images)
        loss = F.cross_entropy(out, labels)
        return loss

    def validation_step(self, batch):
        images, labels = batch
        out = self(images)
        loss = F.cross_entropy(out, labels)
        acc = accuracy(out, labels)
        return {'val_loss': loss.detach(), 'val_acc': acc}

    def validation_epoch_end(self, outputs):
        batch_losses = [x['val_loss'] for x in outputs]
        epoch_loss = torch.stack(batch_losses).mean()
        batch_accs = [x['val_acc'] for x in outputs]
        epoch_acc = torch.stack(batch_accs).mean()
        return {'val_loss': epoch_loss.item(), 'val_acc': epoch_acc.item()}

    def epoch_end(self, epoch, result):
        print("Epoch {}: train_loss: {:.4f}, val_loss: {:.4f}, val_acc: {:.4f}".format(
            epoch+1, result['train_loss'], result['val_loss'], result['val_acc']))

## Cell 7:

import torchvision.models as models
class ResNet(ImageClassificationBase):
    def __init__(self):
        super().__init__()

        self.network = models.resnet18(pretrained=True)

        num_ftrs = self.network.fc.in_features
        self.network.fc = nn.Linear(num_ftrs, len(transformed.classes))

    def forward(self, xb):
        return torch.sigmoid(self.network(xb))

model = ResNet()

# Annotated Target Code:
train_dl: torch.utils.data.DataLoader
val_dl: torch.utils.data.DataLoader


import torch
import torch.nn as nn
import torch.optim as optim
import torch.nn.functional as F
from torch.utils.data import DataLoader





resnet_model = models.resnet18(pretrained=True)


criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(resnet_model.parameters(), lr=0.001, momentum=0.9)


num_epochs = 1

for epoch in range(num_epochs):
    resnet_model.train()
    for inputs, labels in train_dl:
        optimizer.zero_grad()
        outputs = resnet_model(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()


    resnet_model.eval()
    with torch.no_grad():
        correct = 0
        total = 0
        for inputs, labels in val_dl:
            outputs = resnet_model(inputs)
            _, predicted = torch.max(outputs.data, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()

        accuracy = correct / total
        print(f'Epoch {epoch + 1}/{num_epochs}, Validation Accuracy: {accuracy:.4f}')


def evaluate(model, test_dl):
    model.eval()
    with torch.no_grad():
        correct = 0
        total = 0
        for inputs, labels in test_dl:

            inputs = inputs.unsqueeze(-1)
            outputs = model(inputs)

            _, predicted = torch.max(outputs.data, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()

        accuracy = correct / total
        print(f'Test Accuracy: {accuracy:.4f}')



evaluate(resnet_model,val_dl)